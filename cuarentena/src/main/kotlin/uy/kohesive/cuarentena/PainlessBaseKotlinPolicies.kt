package uy.kohesive.cuarentena

import uy.kohesive.cuarentena.policy.AccessTypes
import uy.kohesive.cuarentena.policy.PolicyAllowance
import uy.kohesive.cuarentena.policy.toPolicy

// TODO: move to a policy file/generator outside of here for Kotlin safe calls
object KotlinPolicies {

    val primitiveArrayAccessPolicy = listOf('B','C','D','F','I','J','S','V','Z').map {
        PolicyAllowance.ClassLevel.ClassAccess("[$it", setOf(AccessTypes.ref_Class_Instance))
    }.toPolicy()

    val painlessKotlinBootstrapPolicy = primitiveArrayAccessPolicy + (listOf(
        // This one can't be generated by painless as it needs an actual Class instance, and 'java.lang.Synthetic' is pure synthetic (no pun intended)
        PolicyAllowance.ClassLevel.ClassAccess("java.lang.Synthetic", setOf(AccessTypes.ref_Class)),

        PolicyAllowance.ClassLevel.ClassMethodAccess("kotlin.jvm.internal.Intrinsics", "checkExpressionValueIsNotNull", "(Ljava/lang/Object;Ljava/lang/String;)V", setOf(AccessTypes.call_Class_Static_Method)),
        PolicyAllowance.ClassLevel.ClassMethodAccess("kotlin.jvm.internal.Intrinsics", "checkParameterIsNotNull", "(Ljava/lang/Object;Ljava/lang/String;)V", setOf(AccessTypes.call_Class_Static_Method)),
        PolicyAllowance.ClassLevel.ClassMethodAccess("kotlin.jvm.internal.Intrinsics", "throwNpe", "()V", setOf(AccessTypes.call_Class_Static_Method)),

        // kotlin.Unit
        // This is a tough one as we don't want to replace it with Void
        PolicyAllowance.ClassLevel.ClassFieldAccess("kotlin.Unit", "INSTANCE", "Lkotlin/Unit;", setOf(AccessTypes.read_Class_Static_Field)),

        // kotlin misc
        PolicyAllowance.ClassLevel.ClassAccess("org.jetbrains.annotations.NotNull", setOf(AccessTypes.ref_Class)),
        PolicyAllowance.ClassLevel.ClassAccess("org.jetbrains.annotations.Nullable", setOf(AccessTypes.ref_Class))
    )).toPolicy()

    private fun safeCodeByExample(): List<PolicyAllowance.ClassLevel> {
        val outsidePrimitive = 22

        val classBytes = lambdaToBytes {
            val x = 10 + outsidePrimitive

            emptyList<String>()
            listOf("a")
            listOf("a", "b")
            listOf(1, 2, 3)

            emptySet<String>()
            setOf("a")
            setOf("a", "b")
            setOf(1, 2, 3)

            emptySequence<String>()
            sequenceOf("a")
            sequenceOf("a", "b")
            sequenceOf(1, 2, 3)

            emptyArray<String>()
            arrayOf("a")
            arrayOf(1)
            arrayOf(1L)
            arrayOf(1.0)
            arrayOf(true)
            arrayOf(1, 2, 3)
            arrayOf(1L, 2L, 3L)
            arrayOf(1.0, 2.0, 3.0)
            arrayOf(true, false)


            val lists = listOf("a") + listOf("b") + listOf("c", "d", "e") + listOf("z")

            val s = "stringy $x is next to these $lists"
            val s2 = """$s what $s"""

            val r = """[\w\d]+""".toRegex()
            val p = """[\w\d]+""".toPattern()

            p.toRegex().matches("a99")
            r.matchEntire("asd")?.apply {
                this.groupValues
                this.groups
                this.destructured
                this.value
            }

            "string".takeIf { true }.also { }.takeUnless { false }

            val snullable: String? = ""
            if (snullable != null) {
            } else {
            }
            val snonullable = snullable ?: ""

            true.and(true).or(true).xor(true).not()
        }

        val goodThings = ClassAllowanceDetector.scanClassByteCodeForDesiredAllowances(listOf(classBytes))
        println("===[ sniffed from safe code ]===")
        goodThings.allowances.toPolicy().forEach(::println)
        return goodThings.allowances
    }

    private fun lambdaToBytes(lambda: () -> Unit): NamedClassBytes {
        val serClass = lambda.javaClass
        val className = serClass.name

        return loadClassAsBytes(className, serClass.classLoader)
    }

    private fun loadClassAsBytes(className: String, loader: ClassLoader = Thread.currentThread().contextClassLoader): NamedClassBytes {
        return NamedClassBytes(className,
                loader.getResourceAsStream(className.replace('.', '/') + ".class").use { it.readBytes() })
    }
}